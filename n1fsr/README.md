# n1fsr
**N1CTF 2025**

Дан код реализации криптосистемы на основе нескольких регистров сдвига (LFSR) с фильрацией и маскированием. Код генерирует вывод для 95 байтов текста: первые 80 - нулевые байты, остальные 15 - байты токена. Необходимо получить токен.

Сначала необходимо провести анализ фильтров и LFSR. Для этого через LLM сгенерировал пару скриптов и немного поправил.
Код для анализа фильров: test_filters.py:
1. Вычисляет сбалансированность фильтра (хороший фильтр должен генерировать одинаковое количество 0 и 1)
2. Определяет нелинейность фильтра через преобразование Уолша-Адамара
3. Вычисляет алгебраическую степень полинома, соответствующего фильтру

Код для анализа LFSR с маскирвоанием: test_masks.py:
1. Вычисляет полином, соответствующий данному LFSR
2. Находит длину цикла

Результаты анализа:
1. Второй фильтр `69474900172976843852504521249820447513188207961992185137442753975916133181030` - линейный
2. У LFSR 3 с маской `0x83c7efefc783` короткий цикл: 63
3. У LFSR 4, 5, 6, 7 (индекс начинается с нуля) одинаковое количество входов (8) и одинаковые длины циклов: 255

Будем рассматривать начальные состояния LFSR как неизвестные. Пусть начальные состояния LFSR без фильтра или с линейным фильтром - это переменные $x_1, ..., x_32, x_33, ..., x_56$. Для LFSR 3 с коротким циклом обозначим выходные состояния как $x_57, ..., x_119$. LFSR с одинаковой длиной цикла можно объекдинить в один LFSR. Его начальные состояния обозначим как $x_120, ..., x_374$. 
Для LFSR 0 и LFSR 8 прямая линеаризаия даст $\sum_{i=1}^7 (\binom{14}{i}+\binom{10}{i})$ переменных. Такой подход даст слишком много неизвестных, но можно забрутфорсить 7 бит для LFSR 0 и 3 бита для LFSR 8. Таким образом получим еще $2^{14-7} - 1 + 2^{10-3} - 1 = 254$ переменных.
Таким образом мы получим систему линейных уравнений от 628 переменных $x_1, ..., x_628$. Заранее, перед взаимодействием с сервером, подготовим $2^10$ матриц, значения которых - результаты работы LFSR. Получив данные от сервера, нам необходимо решить матричное уравнение для каждой из подготовленных матриц и вектора шифртекста. Найдя решение, можно по аналогии восстановить из него нужную матрицу и получить оставшуюся часть ключевого потока.

#crypto #lfsr #linear_algebra