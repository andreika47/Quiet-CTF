# n1^3
**N1CTF 2025**

Дан коротенький файл с кодом task.sage и огромный файл с результатом вывода output.txt.
```
FLAG = ZZ.from_bytes(os.getenvb(b"FLAG", b"n1ctf{.*}")[6:-1]).digits(257)
F, n = GF(257), len(FLAG)
U, T = [random_matrix(F, n) for _ in ':)']
enc = lambda x: (x * U).apply_map(lambda c: c^3) * T
print(enc(vector(F[",".join(f"x{i}" for i in range(n))].gens())))
print(enc(vector(F, FLAG)))
```

Задание по сути является интерпретацией схемы цифровой подписи 3WISE. Даны публичный ключ - массив полиномов, и шифртекст. И публичный ключи, и шифртекст получены по одному и тому же преобразованию, на котором основана подпись.
Флаг представляется в виде элементов поля Галуа с характеристикой 257. Далее, генерируются две случайные матрицы `U` и `T` с элементами из этого поля. Функция шифрования следующая:
```math
E(x) = F(x * U) * T,
```
где преобразование `F` - это возведение каждого элемента матрицы в куб.

Авторское решение предполагает реализацию атаки из статьи про взлом 3WISE: https://eprint.iacr.org/2023/1535.pdf
Основная идея заклчается в представлении функции шифрования в виде тензора:
```math
E(x) = F(x * U) * T = \sum_{i=1}^N (t_i * (u_i * x)^3),                                                     (1)
```
где $t_i$ - векторы-строки матрицы `T`, $u_i$ - векторы-строки матрицы `U`.
Рассмотрим множитель с возвдением в куб. Его можно представить в виде следующе суммы:
```math
(u * x)^3 =\sum_{(i,j,k)} (u_iu_ju_kx_ix_jx_k).                                                      (2)
```
Тогда функцию `E(x)` можно представить в виде трехмерного тензора:
```math
S[i, j, k] = \sum_{m=1}^N (t_m[i] * u_m[i] * u_m[j] * u_m[k])                                          (3)
```
Подобное представление возмодно, так как в сумме (2) коэффициенты мономом по сути являются тензорным произведением $u_i \otimes u_j \otimes u_k$ и соответствуют элементам тензора.
Полученный тензор необходимо разложить на линейную комбинацию тензоров меньшего размера, в нашем случае - матриц. В статье данная задача сводится к решению проблемы MinRank и реализации одного из алгоритмов решающих данную задачу. Альтернативным решением является использование алгоритма Йенриха для декомпозиции тензоров.
Суть алогоритма в фиксации одного из измерений и подборе случайной линейной комбинации тензоров меньшей размерности. В нашем случае мы генерируем 3 случайных вектора `a, b, c`, вычисляем тензорное произведение $S(c) = S \otimes c$, а затем вычисляем две матрицы:
```math
A = S(c) \otimes a
```
```math
B = S(c) \otimes b
```
Если `B` - обратима, то считаем наше вычисление успешным и пытаемся вычислить подобные преобразования для исходных матриц `U` и `T`. Сначала вычислим
$X = A * B^{-1}$. Правые собственные вектора `X` будут строками для матрицы `V`, которая является подобным преобразованием к умножению вектора `x` на матрицу `U`.
Далее вычислим $W = F(V)^{-1} * I$, где `I` - матрица, состоящая из значений полиномов на единичных векторах (i-ая единичный вектор означает, что на i-ой позиции в векторе стоит единица, а остальные позиции - нули). Матрица `W` является подобным преобразованием к умножению вектора на матрицу `T`.

Далее поэтапно применяем обратные подобные преобразования:
1. Находим $F(x * U) = (W^T)^{-1} * ct$, где `ct` - шифртекст
2. Для извелечения корня найдем обратный к 3 по модую 256 (число элементов группы по умножению в поле GF(257)): $3^{-1} = 171 mod 256$. Умножив каждый элемент в полученном векторе на найденный обратный получим вектор `ux`
3. Искомый $x = (V^T)^{-1} * ux$

#crypto #sign #linear_algebra